# 2020届秋招面试题总结1——JAVA基础篇

**1、JAVA中的几种数据类型是什么，各自占用多少字节。**

Java语言提供了八种基本数据类型。六种数据类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。

- byte：1字节，表示范围是-128~127之间。
- short：2字节，表示范围是-32768~32767之间。
- int：4字节，表示范围是负的2的31次方到正的2的31次方减1。
- long：8字节，表示范围为负的2的63次方到正的2的63次方减1。
- float：4字节，表示范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。
- double：8字节，表示范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。
- boolean：只有true和false两个取值。
- char：2字节，存储Unicode码，用单引号赋值。

**2、String类能被继承吗，为什么。**

不能被继承，因为String类有final修饰符，而final修饰的类是不能被继承的。

```java
public final class String implements java.io.Serializable, Comparable<String>, CharSequence {
    // 省略...
}
```

**3、String，StringBuffer，StringBuilder的区别。**

String为字符串常量（因为内部数组value[]有final修饰），因此数组引用无可修改。并且String不提供修改数组元素的方法，因此无法修改数组引用，也无法修改数组元素。

而StringBuilder和StringBuffer均为字符串变量（因为内部数组value[]没有final修饰），并且提供了修改数组元素的方法，可以修改数组引用，也可以修改元素。

String变量创建后是放入方法区的常量池（或者常量池）中，而StringBuilder和StringBuffer则是存入堆中。

在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的，因为StringBuffer在增删改查方法上添加了synchronized修饰。


***3.1 StringBuilder、StringBuffer的扩容方式 ***

StringBuilder和StringBuffer默认数组长度为0，若给构造函数传递容量时，那初始长度就是传递的值。

StringBuilder和StringBuffer都继承自AbstractStringBuilder，因此它们的数组扩容方式一致。当新增元素时>capacity，扩容为capacity * 2 + 2;

***3.2 字符串常量池 ***

构造String对象的方式有很多，String的内存分配比较特殊：

- 方式一：String str1="123";

通过引号直接创建字符串对象，先会从常量池中判断是否存在"123"对象，如果不存在，则会在常量池中创建该对象，并且返回常量池中"123"对象的引用给str；如果之前常量池存在"123"的话，则直接返回常量池中"123"的对象引用。

- 方式二：String str2=new String("123");

首先"123"是一个常量字符串，因此会先在常量池创建"123"字符串对象，然后在堆中再创建一个字符串对象，将常量池中的"123"字符串复制到堆中新创建的对象字符数组中，因此该方式不仅会在堆中，还会在常量池中创建"123"字符串对象。

- 方式三：String str3="123".intern();

该种方式通过intern方法返回一个字符串引用，intern方法是一个native方法，当常量池中存在"123"字符串常量时，则直接返回该常量池中的字符串引用；若不存在，则会先在常量池中创建"123"字符串对象，然后返回新创建对象的引用，与方式一类似。该方法常用于将某些经常访问的字符串对象保存在常量池中，避免经常创建对象。
方式四：String str4=str2.intern();

该种方式是在方式二基础上进行的，intern 方法会先判断常量池中是否存在与str2 相同字符串的对象，若有，则返回该引用；若无，则在常量池创建一个引用（CONSTAT_String_info）指向 str2，然后返回该引用，实际上返回的是 str2 的引用。


***3.3 字符串连接***

在 Java 中，对于字符串连接它会优化成使用 StringBuilder 来完成连接。

例1:
```
String s1 = "123";
String s2 = s1 + "456";
```

实际代码为：
```
String s1 = "123";
String s2 = new StringBuilder.append(s).append("456").toString();
```
例1中，常量池中有“123” 和 “456” 两个字面量，然后在堆中创建一个 “123456” 对象，这里涉及了三个对象的创建。

例二：
```
String s1 = "123" + "456";
```
字面量的连接，Java 会将其优化成 String s1 = “123456”，最终这里只在方法区的常量池中创建一个对象。


**4、讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段。当new的时候，他们的执行顺序。**

Java程序的初始化一般遵循3个原则（优先级以此递减）：

- 静态对象（变量）优先于非静态对象（变量）初始化，其中，静态对象（变量）只初始化一次，而非静态对象（变量）可能会初始化多次。
- 父类优先于子类进行初始化。
- 按照成员变量的顺序进行初始化。

当new时，他们的执行顺序为：

1． 父类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行。

2． 子类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行。

3． 父类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行。

4． 父类构造方法。

5． 子类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行。

6． 子类构造方法。


**9、抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口吗，类可以实现多个接口吗。**

抽象类和接口的区别有：

- 抽象类可以有自己的实现方法，接口在jdk1.8之后才可以有自己的实现方法（用default修饰）。
- 抽象类的抽象方法必须由继承的子类实现，如果子类不实现，则子类也需要定义为抽象的；接口的抽象方法必须由实现类来实现，如果实现类不能实现接口中所有方法，则将实现类定位为抽象类。
- 抽象方法必须是pulic/protected，接口中的变量隐式指定为public static final变量，抽象方法被隐式指定为public abstract。
- 抽象类中可以存在普通属性、方法、静态属性和方法。如果一个类中有一个抽象方法，那么当前类肯定是抽象类。
- 子类只能继承一个父类，接口可以继承多个接口，类似于：Interface1 Extends Interface2, Interface3, Interface4……
- 类也可以实现多个接口。

主要注意的是，抽象方法不能用synchronized修饰。

从设计角度来看抽象类和接口：

- 抽象类是is a，是实例必须要有的，比如Door必须有开和关。而接口就是has a，可以有也可以没有，比如Door可以有报警器，但不是必须的，是可拓展的行为。
- 抽象类强调的是同类事务的抽象，接口强调的是同类方法的抽象。
- 抽象类是从子类中发现了公共的东西，泛化出父类，然后子类继承父类；接口是根本不知道子类的存在，方法如何实现还不确认，预先定义。
- 若行为跨越不同类的对象，可使用接口；对于一些相似的类对象，用继承抽象类。

**10、继承和聚合的区别在哪。**

分别介绍这几种关系：

- 继承：指的是一个类继承另一个类的功能，并可以增加自己的的新功能的能力，Is-A继承关系是类与类或者接口与接口之间最常见的关系。在Java类中通过关键词extends明确标识。

  ![YWvf1J.png](https://s1.ax1x.com/2020/05/18/YWvf1J.png)

- 实现：指的是一个class类实现interface接口（可以多个）的功能，实现是类与接口之间最常见的关系。在Java类中通过关键词implements明确标识。

  ![YWvo0x.png](https://s1.ax1x.com/2020/05/18/YWvo0x.png)

- 依赖：可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、、临时性的、非常弱的，但是B类的变化会影响到A；比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖；表现在代码层面，为类B作为参数被类A在某个method方法中使用。

  ![YWvT76.png](https://s1.ax1x.com/2020/05/18/YWvT76.png)

- 关联：关联关系在java中一般使用成员变量来实现，有时也用方法形参的形式实现。依然使用Driver和Car的例子，使用方法参数形式可以表示依赖关系，也可以表示关联关系，毕竟我们无法在程序中太准确的表达语义。

  ![YWvrmq.png](https://s1.ax1x.com/2020/05/18/YWvrmq.png)

- 聚合：是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享；比如计算机与CPU、公司与员工的关系等。

  ![YWv4XR.png](https://s1.ax1x.com/2020/05/18/YWv4XR.png)

- 组合(a拥有b，a没了b也就没了，实心)：也是关联关系的一种特例，他体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合；他同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束；比如你和你的大脑；表现在代码层面，和关联关系是一致的，只能从语义级别来区分；

  ![YWvHAK.png](https://s1.ax1x.com/2020/05/18/YWvHAK.png)

  具体代码层次理解可以看这篇文章： [java--依赖、关联、聚合和组合之间区别的理解]( https://www.cnblogs.com/wanghuaijun/p/5421419.html)

**11、讲讲你理解的nio，他和bio的区别是什么，谈谈reactor模型。**

&emsp;&emsp;
IO技术是实现客户端与服务器的基本方法，其中最重要的是实现高性能服务器，nio，bio，aio就是实现服务器的基本方法。服务器IO的读取的两个阶段：
- 服务器端等待客户端的消息，收到消息后，在操作系统内核存储消息。
- 操作系统内核将消息从内核态复制到用户态中。

解释一下同步与异步：

- 同步IO，是一种用户空间与内核空间的调用发起方式。同步IO是指用户空间线程是主动发起IO请求的一方，内核空间是被动接受方。

- 异步IO则反过来，是指内核kernel是主动发起IO请求的一方，用户线程是被动接受方。

再解释一下阻塞和非阻塞：

- 阻塞是指用户空间（调用线程）一直在等待，而且别的事情什么都不做；

- 非阻塞是指用户空间（调用线程）拿到状态就返回，IO操作可以干就干，不可以干，就去干的事情。



- BIO：同步阻塞式IO，BIO在在IO读取的两个阶段时，线程都是阻塞的。比如accpet，read，这些操作都会阻塞线程。

- NIO：同步非阻塞式IO，客户端发送的连接请求都会注册到多路复用器上，这是内核会监控多个socket，内核会主动接收socket消息，用户只需要阻塞读取内核消息就行。NIO基于事件驱动思想完成的。NIO由Selecctor、Buffer、Channel组成。

- AIO：异步非阻塞式IO，内核完成了IO读取的两个阶段，结束后通知用户线程执行相应逻辑。

reactor模型：反应器模式（事件驱动模式）：

1.同步的等待多个事件源到达（采用select()实现）

2.将事件多路分解以及分配相应的事件服务进行处理，这个分派采用server集中处理（dispatch）

3.分解的事件以及对应的事件服务应用从分派服务中分离出去（handler）

I/O多路复用是指内核一旦发现进程中指定的一个或者多个IO条件准备读取，它就通知该进程。也可以理解为，使用一个线程来检查多个文件描述符(Socket)的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行(比如使用线程池)。

具体reactor可以看这篇文章： [Reactor模式详解]( https://www.cnblogs.com/winner-0715/p/8733787.html)

在Java中，Selector这个类是select/epoll/poll的外包类。


**12、select、poll和epoll之间的区别。**

目前支持I/O多路复用的系统调用有select、poll和epoll，I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select、poll和epoll本质上都是同步I/O，因为它们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。

与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。

- select

select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。

它的优点是跨平台性能好，几乎在所有的平台上都支持。

select的不足在三个方面，第一个是单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024。第二个是对socket进行扫描时是线性扫描，即采用轮询的方式，效率较低。第三个是需要维护一个用来存放大量fd的数据结构，这样会使用户空间和内核空间在传递该结构时复制开销大。

- poll

poll和select没有区别，它的优点是没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点，则是大量的fd数组被整体复制于用户态和内核地址之间。

- epoll

epoll是select和poll的增强版本，相对于前两者来说，它更加灵活，没有描述符的数量限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。所有的fd都存入红黑树中。

epoll支持水平触发和边缘触发，最大的特点是边缘触发，它只告诉线程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll通过“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来把该fd放入到双向链表（保存已就绪的事件），epoll_wait便可以收到通知。

epoll的优点主要是三个方面：第一是没有最大并发连接的限制，能打开的FD的上限远大于1024；第二是使用链表存储发生事件的fd，而不是轮询的方式，不会随着FD数目的增加效率下降，这时候用到了回调；第三是内存拷贝，使用mmap减少了复制开销。

综上：

- 表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。
- select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善。

***11.1、红黑树与平衡二叉树的区别***

平衡二叉树追求的是绝对平衡！也就是说左子树和右子树差值必须小于等于1




**34、二叉树、平衡二叉树、红黑树的性质。**

普通的二叉查找树的性质是：

- 若它的左子树不空，则左子树上所有结点的值均小于它的根节点的值；
- 若它的右子树上所有结点的值均大于它的根节点的值；
- 它的左、右子树也分别为二叉排序树。

平衡二叉树，又被称为AVL树，它的左右两个子树的高度差不能超过1。平衡二叉树的目的是为了减少二叉查找树层次，提高查找速度。

- 红黑树，也是一种近似的平衡二叉树。红黑树的每个节点上都有存储位表示节点的颜色，可能是红或黑。红黑树只需要保证左右子树中的黑色节点数量一致即可。这是赤裸裸的走捷径啊。这只是保证了黑色节点的绝对平衡，红色节点是不考虑的，也就是说左子树和右子树只要满足2倍以内的关系就可以了。

红黑树的特性是：
- 每个节点或者是黑色，或者是红色。
- 根节点是黑色。
- 每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
  如果一个节点是红色的，则它的子节点必须是黑色的。
- 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。

[红黑树超棒资料](https://www.cnblogs.com/CarpenterLee/p/5503882.html)

红黑树的时间复杂度为O(logN)，效率很高。

有一个比较有意思的小公式，树中节点数=总分叉数+1。（这里的分叉数就是所有节点的度之和）

后续的B-树或者B+树都是多路搜索树。


**12、反射的原理，反射创建类实例的三种方式是什么。**

反射机制：Java反射机制是在运行状态中，对于任意一个类，如果知道一个类的名称，就可以获取类的Class对象，调用Class对象可以调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。

反射获取Class对象有三种方式：
- 使用Class.forName("类路径名称")静态方法。
- 使用类的.class方法。
- 使用实例对象的getClass()方法。

根据Class获取实例对象有两种方式：

- 直接使用字节码文件获取对应实例，Object o=clazz.newInstance();
- 对带参数的构造函数的类，先获取到其构造对象，再通过该构造方法类获取实例，如下。

```java
/ /获取构造函数类的对象
Constroctor constroctor = clazz.getConstructor(String.class,Integer.class);
// 使用构造器对象的newInstance方法初始化对象
Object obj = constroctor.newInstance("龙哥", 29);
```
**40、如何通过反射获取和设置对象私有字段的值。**

可以通过类对象的getDeclaredField()方法字段（Field）对象，然后再通过字段对象的setAccessible(true)将其设置为可以访问，接下来就可以通过get/set方法来获取/设置字段的值了。代码如下所示。

```java
public class Test {
    static class User {
        private String name;
        private int age;
    }
    public static void main(String[] args) {
        Class<User> clz = User.class;
        try {
            Field age = clz.getDeclaredField("age");
            age.setAccessible(true);
            Object obj = clz.newInstance();
            age.setInt(obj, 18);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

**13、反射中，Class.forName() 和ClassLoader.loadClass()区别。**

&emsp;&emsp;
Class.forName("className")和ClassLoader.loadClass("className")都是用于加载.class文件到jvm中，并在堆中创建Class对象。

- Class.forName()

Class.forName(className)方法，内部实际调用的方法是  Class.forName(className,true,classloader);

第2个boolean参数表示类是否需要初始化，  Class.forName(className)默认是需要初始化。一旦初始化，就会触发目标对象的 static块代码执行，static参数也也会被再次初始化。

- ClassLoader.loadClass()    

ClassLoader.loadClass(className)方法，内部实际调用的方法是  ClassLoader.loadClass(className,false);

第2个 boolean参数，表示目标对象是否进行链接，false表示不进行链接，由上面介绍可以，不进行链接意味着不进行包括初始化等一些列步骤，那么静态块和静态对象就不会得到执行。


**22、类加载过程。**

Java虚拟机中类加载的全过程包括：加载、验证、准备、解析和初始化这5个阶段。

**加载:**

在加载阶段，虚拟机主要完成以下3个事情。

- 通过一个类的全限定名来获取定义此类的二进制字节流。（这一步骤就是通过类加载器来实现的）
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各类数据的访问入口。

**验证:**

验证时连接阶段的第一步，这一阶段的目的是为了**确保Class文件的字节流中包含的信息符合当前虚拟机的要求**，并且不会危害虚拟机自身的安全。

- 文件格式验证：验证字节流是否符合Class文件格式的规范，包括文件头部的魔数因子、class文件主次版本号、class文件的MD5指纹等。
- 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范。简单来说就是验证Java语法的正确性。
- 字节码验证：主要验证程序的控制流程，如循环、分支等。

**准备:**

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在**方法区**中分配。需要注意的是，这时候进行内存分配的仅包括**类变量（被static修饰的变量）**，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。

**解析:**

解析阶段是虚拟机在常量池内寻找类、接口、字段和方法的符号引用，并且将这些**符号引用替换为直接引用**的过程。符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。

**初始化:**

初始化阶段是类的加载过程的最后一个阶段，该阶段主要做一件事情就是执行&lt;clinit&gt;()，该方法**会为所有的静态变量赋予正确的值**。


**14、描述动态代理的几种实现方式，分别说出相应的优缺点。**

代理目的是增强代理对象的方法，动态代理有两种实现方式，分别是：jdk动态代理和cglib动态代理。

- jdk动态代理的前提是目标类必须实现一个接口，代理对象跟目标类实现一个接口。

- cglib动态类是继承并重写了目标类（enhancer.create()方法返回的就是一个继承目标类的子类），所以目标类和方法不能被声明为final。

具体可以看我的另一篇文章，详细讲解了，[记动态代理](../notes/记动态代理.md)

CGLib创建的动态代理对象性能比JDK创建的动态代理对象的性能高不少，但是CGLib在创建代理对象时所花费的时间却比JDK多得多，所以对于单例的对象，因为无需频繁创建对象，用CGLib合适，反之，使用JDK方式要更为合适一些。

CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。CGLib继承被代理类，因此被代理类不能是final

[动态代理视频](https://www.bilibili.com/video/BV1Dt41187wj?from=search&seid=1847877076374930790)


**15、JDK动态代理与cglib实现的区别。**

- JDK动态代理是通过接口中的方法名，在动态生成的代理类中调用业务实现类的同名方法；

JDK根据接口创建了接口的实现类的字节码，加载并生成代理类对象。
通过实现InvocationHandler接口，重写invock()函数对接口的方法对被代理的对象方法进行增强；
通过代理类对象调用通过实现InvocationHandler实现类的增强的方法。


- CGlib动态代理是通过继承并重写目标业务类，生成的动态代理类是业务类的子类，通过重写业务方法进行代理；

利用ASM开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。


**15.1、为什么CGlib方式可以对接口实现代理。**

cglib动态代理是继承并重写目标类，所以目标类和方法不能被声明为final。而接口是可以被继承的。

**17、final的用途。**

- final修饰的对象不能被修改。
- final修饰的类不能被继承。
- final修饰的方法不能被重写（但可以被重载）。

**18、写出三种单例模式实现。**

单例模式的意思就是只有一个实例。单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类成为单例类。

单例模式有三种：懒汉式单例，饿汉式单例，二次验证懒汉单例（最好的）。

[单例模式](https://www.cnblogs.com/ygj0930/p/10845530.html)

**19、如何在父类中为子类自动完成所有的hashcode和equals实现，这样做有何优劣。**

两个对象equals相等，就表示这两个对象实际上就是一个对象。

父类的equals不一定满足子类的equals需求。比如所有的对象都继承于Object，默认使用的是Object的equals方法，在比较两个对象的时候，是看他们是否指向同一个地址。

如果令对象的所有成员相等，对象就相等。而默认的equals方法满足不了当前的需求，所以要重写equals方法，加入自定义逻辑。

重写equals方法就必须重写hashcode方法，如果不重写hashcode，会导致两个相同的对象都插入到map中，造成内存浪费。

**20、请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。**

OO面向对象编程的设计理念是：

- 抽象，先不考虑细节

- 封装，隐藏内部实现

- 继承，复用现有代码

- 多态，改写对象行为

封装，也就是把客观事物封装成抽象的类，并且类可以把自己的变量和方法只让可信的类或者对象操作，对不可信的进行隐藏，所以我们可以通过修饰符public、private、protected、default来进行访问控制。

| 修饰符    | 类内部 | 本包 | 子类 | 外部包 |
| --------- | ------ | ---- | ---- | ------ |
| public    | √      | √    | √    | √      |
| protected | √      | √    | √    | ×      |
| default   | √      | √    | ×    | ×      |
| private   | √      | ×    | ×    | ×      |

**21、深拷贝和浅拷贝的区别。**

- 浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝。

- 深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容。

**22、数组和链表数据结构描述，各自的时间复杂度。**

- 数组是将元素在内存中连续存放，由于每个元素占用内存空间相同，可以通过下标迅速访问数组中任何元素。
- 链表恰好相反，链表中元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。
- 数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)；
- 数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。
- 数组和栈都存放在堆中，在虚拟机栈中只需要定义引用变量即可。

**23、error和exception的区别，CheckedException，RuntimeException的区别。**

- Exception和Error都是继承于Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。

- error（错误）表示系统级的错误和程序不必处理的异常，是java运行环境中的内部错误或者硬件问题。比如：内存资源不足等。对于这种错误，程序基本无能为力，除了推出运行外别无选择，它是由java虚拟机抛出的，是不可预料的异常情况。

- Exception（违例）表示需要捕捉或者需要程序进行处理的异常，他处理的是因为程序设计的瑕疵而引起的问题或者在外的输入等引起的一般性问题，是程序必须处理的，是可预料的异常情况。Exception分为受查异常和非受查异常。

- RuntimeException（非受查异常）在代码编写时可以忽略捕获操作（比如：ArrayIndexOutOfBoundsException），这种异常是在代码编写或者使用过程中通过规范可以避免发生的。
 - 运行时异常：都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。
 - 非运行时异常 （编译异常）：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。

**24、请列出5个运行时异常。**

- NullPointerException(空指针)
- IndexOutOfBoundsException(数组越界)
- ClassCastException(类转换异常)
- ArrayStoreException(数据存储异常，操作数组时类型不一致)
- IllegalArgumentException（非法参数异常）

**25、在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么。**

不可以，双亲委派模式会保证父类加载器先加载类，就是BootStrap（启动类）加载器加载jdk里面的java.lang.String类，而自定义的java.lang.String类永远不会被加载到。

如果打破双亲委派模式，自己写一个classLoader来加载自己写的java.lang.String类，但是也会发现也不会加载成功，具体就是因为针对java.*开头的类，jvm的实现中已经保证了必须由bootstrp来加载。

**26、说一说你对java.lang.Object对象中的hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。**

Object类中的equals方法和“==”是一样的，没有区别，即俩个对象的比较是比较他们的栈内存中存储的内存地址。而String类，Integer类等等一些类，是重写了equals方法，才使得equals和“==不同”，他们比较的是值是不是相等。所以，当自己创建类时，自动继承了Object的equals方法，要想实现不同的等于比较，必须重写equals方法。比如我们的需求是对象的某个属性相同，就相等了，而默认的equals方法满足不了当前的需求，所以我们要重写equals方法。

如果重写了equals方法就必须重写hashcode方法，hashcode用于计算元素在数组中的下标。

如果你重写了equals，比如说是基于对象的内容实现的，而保留hashCode的实现不变，那么很可能某两个对象明明是“相等”，而hashCode却不一样。

这样，当你用其中的一个作为键保存到hashMap、hasoTable或hashSet中，再以“相等的”找另一个作为键值去查找他们的时候，则根本找不到。


**29、有没有可能2个不相等的对象有相同的hashcode。**

有可能，最简单的方法是在自己实现类中重写hashcode()方法。

**27、在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。**

那些拥有Java1.4或更早版本的开发背景的人都知道，在集合中存储对象并在使用前进行类型转换是多么的不方便。泛型防止了那种情况的发生。它提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException。泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如List<String>在运行时仅用一个List来表示。这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。
    
有两种限定通配符，一种是<? extends T>它通过确保类型必须是T的子类来设定类型的上界，另一种是<? super T>它通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面<?>表示了非限定通配符，因为<?>可以用任意类型来替代。List<? extends T>可以接受任何继承自T的类型的List，而List<? super T>可以接受任何T的父类构成的List。例如List<? extends Number>可以接受List<Integer>或List<Float>。
    
不可以把List<String>传递给一个接受List<Object>参数的方法，乍看起来String是一种Object，所以List<String>应当可以用在需要List<Object>的地方，但是事实并非如此。真这样做的话会导致编译错误。如果你再深一步考虑，你会发现Java这样做是有意义的，因为List<Object>可以存储任何类型的对象包括String, Integer等等，而List<String>却只能用来存储Strings。　

**31、什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。**

序列化是一种用户处理对象流的机制，所谓对象流就是将对象的内容进行流化。

- 序列化：使用ObjectOutputStream的writeObject()把对象转换为字节序列的过程称为对象的序列化。
- 反序列化：使用ObjectInputStream的readObject()把字节序列恢复为对象的过程称为对象的反序列化。

对象实现序列化只需要实现Serializable接口即可。
若部分数据不序列化，则使用transist。
Java序列化的的是对象的非静态字段及其值，static静态成员属于类变量，也无法被序列化。

**32、java8的新特性。**

- Lambda表达式和函数式接口
- default关键字修饰，给接口添加一个非抽象的方法实现。
- 函数式接口。
- Stream串形化编程。


**35、Java的IO流用了什么设计模式。**

ava IO流的设计是基于装饰者模式&适配模式，面对IO流庞大的包装类体系，核心是要抓住其功能所对应的装饰类。

装饰模式又名包装（Wrapper）模式。装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。装饰模式通过创建一个包装对象，也就是装饰，来包裹真实的对象。装饰模式以对客户端透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不创造更多子类的情况下，将对象的功能加以扩展。装饰模式把客户端的调用委派到被装饰类。装饰模式的关键在于这种扩展是完全透明的。

例如，InputStream就是装饰者模式中的超类，BufferedInputStream，FileInputStream相当于被装饰者，FilterInputStream就是装饰者。其中，BufferedInputStream将FilterInputStream获取的字节进行缓存，提供了缓存的功能，这实现了功能的增强。


适配器模式：不同的接口的实现类实现方法不同，通过适配器类根据输入的类型调用对应的方法。对这些不同的接口对象进行统一管理。

**36、Java中对象的引用。**

Java语言中，除了原始的八个基本数据类型外，其他都是引用类型，指向各种不同的对象。不同的引用类型，不同之处在于对象不同的可达性及对垃圾回收的影响。主要分为：

- 强引用：

只要引用存在，垃圾回收器永远不会回收。例如：

```java
Object obj = new Object(); //其中obj就是强引用。通过关键字new创建的对象所关联的引用是强引用。
```

特点：JVM内存空间不足时，JVM宁愿抛出OutOfMemoryError（OOM）运行时错误，使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通对象，如果没有其他的引用关系，只要超过了引用的作用域（如超出局部变量作用范围）或者显示将相应（强）引用赋值为null，就可以根据具体的垃圾回收机制被回收。

- 软引用：

软引用通过SoftReference实现，非必须引用，生命周期比强引用短一些，内存溢出之前进行回收。

应用场景： 软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。

- 弱引用：

弱引用通过WeakReference类实现，弱引用的生命周期比软引用短，被弱引用关联的对象只能生存到下一次垃圾回收之前，。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现具有弱引用的对象，不管当前的内存空间足够与否，都会回收他的内存。（由于垃圾回收器县城是一个优先级很低的线程，因此不一定会很快回收弱引用的对象）。ThreadLocal为了避免内存泄漏，会将key作为ThreadLocal对象的弱引用。

应用场景：弱引用同样是很多缓存实现的选择。

- 幻象引用（虚引用）：

通过PhantomReference类来实现。无法通过幻象引用访问对象的任何属性或函数。幻象引用仅仅是提供一种确保对象被finalize以后，做某些事情的机制。如果一个对象仅持有幻象引用，那么他就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须搭配引用队列一起使用，只适用于内存回收的场景，当内存回收时，虚引用的对象进入队列，开发者就知道被对象回收了。

**38、final修饰的变量是引用不可变，还是引用的对象不能改变。**

final修饰的变量是引用不可变，但是引用的对象还是可以发生改变。

如果final修饰的是一个基本数据类型的变量，那么这个变量就确定了，不能变了。

而如果final修饰的是一个引用变量，那么该变量存的是一个内存地址，该地址就不能变了，但是该地址所指向的那个对象还是可以变的。

举个例子

```Java
final StringBuilder sb=new StringBuilder();
//sb=new StringBuilder();//程序报错。
sb.append("a");//成功执行，sb对象内部可以改变。
```

**39、Java中Comparable和Comparator接口的区别。**

Comparable是排序接口，若一个类实现了Comparable接口，就意味着这个类支持排序，不需要再去指定比较器。接口中通过x.compareTo(y)来比较x和y的大小。若返回负数，意味着x比y小；返回零，意味着x等于y；返回正数，意味着x大于y。

Comparator是比较器接口。我们若需对某个类集合进行排序，而该类本身不支持排序（即没有实现Comparable接口），那么，我们就可以建立一个“该类的比较器”来进行排序。这个比较器只需要实现Comparator接口即可。

两者的联系则为：Comparable相当于内部比较器，而Comparator相当于外部比较器。



**41、sleep()方法和yield()方法的区别。**

两个方法都是Thread类的方法。
- sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会。
- 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态。


需要注意的是：

如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep/join，则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。
