# 2020届秋招面试题总结——Redis篇

**重点**：
- redis数据结构
- redis集群
- redis与数据库
- redis分布式锁
- redis优化

**1、Redis的优势。**

- 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)。
- 支持丰富的数据类型，支持string，list，set，zset和hash。
- 支持事务性。操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行。（这块需要注意与之前MySQL不同）
- 丰富的特性，可用于缓存，消息队列，按key设置过期时间，过期后将自动删除。

**2、Redis的数据结构都有哪些。**

key是String类型，Redis的数据结构是指value的数据类型。

Redis支持五种Value Type:
- String:底层由SDS实现。 应用：常规计数：微博数，粉丝数等。
  -- SDS由len和free以及char[]数组构成，len表示元素占用的字节数，free表示可用空间数，char[]用来存放实际数据。
  
  -- SDS根据len作为偏移量查询每个元素，而不是根据下标，当数组中的数据有'\0'时，依然能存储，它是二进制安全的数组。
  
  -- SDS根据free来动态扩容，当数组空间不够时，扩容，而普通的string每次赋值都会重新申请内存，非常浪费。
  
  由于len和free都是int类型，共占8个字节，而char[]数组的容量可能远远小于8个字节，使用int会浪费内存。因此redis进行优化，采用更小的结构存储len，free。根据char[]数组实际的容量len和free的type从int_8、int_16、int_32、int_64不等。
  
  redis每个value数据都是RedisObject类型。RedisObject存储的类型是上述的五种类型。
  
  -- 当数组大小小于44时，采用embstr的类型，将redisObject头和数组元素连续内存分配，这样44 + len(redisObject头) < 64byte，可以充分利用L1缓存，不需要额外IO。
    
  -- 当数组大小大于44时，采用raw类型，redisObject的ptr指向数组内存， 这样redisobjct加载到L1缓存后，再执行一次IO加载数组。
  
  -- 当数组内容是数字是，采用int存储，可以执行incr等算术操作。
  
- list：底层由ziplist或linkedlist实现。应用：排行榜、一个消息队列。

  -- linkedlist额外加入了pre和next指针，在64位系统中每个结点额外占用来16byte，非常浪费内存，采用ziplist进行优化。并且会产生外部碎片，系统无法使用。
  
  -- ziplist内存是连续分配的，每个节点通过len表示结点的大小。这样节省linkedlist所创建的指针，还压缩内存。
 

- hash：底层由ziplist或hashtable实现。

  -- 当元素低于512个，采用ziplist，节省内存。超过512个，采用hashtable。
  -- hashtable在扩容，链表等类似java的hashmap，但是hashtable采用两个hashtable，用于渐进式扩容。即当新元素加入hashtable时，在新的table中分配，而不是一次性地扩容，一次性扩容会导致瞬间过高地占用内存。
  
- set：底层由intset或hashtable实现。如果set中是数字，使用intset，否则hashtable。 应用：共同关注、共同喜好。

- zet：底层由ziplist或skiplist实现。通过分数排序，skiplist底层采用链表，通过分层的思想实现二分法。应用：排行榜应用，取TOP N操作。

- bitmap：bitmap底层用一个byte[]数组存储数据，bitmap将每一个key作为下标，该下标对应数组的每一个bit，非常节约内存。

应用：
--统计日活：对于当天活跃用户，设置其对应的bit为1，最后统计数组上为1的个数，统计结果就是日活。

--连续打卡人数：将第二天的bitmap数组和第一天的bitmap数组进行&操作，统计1的个数，就是连续两天打卡人数。

--周活：连续&七个数组。

--月活：连续&三个数组。

[Redis数据类型及底层原理](https://www.cnblogs.com/MouseDong/p/11134039.html)


**15、Redis中set和zset的区别。**

set是Redis下的无序集合对象，是通过intset或者hashtable编码实现。

zset是Redis下的有序集合对象，是通过ziplist或者skiplist编码实现。

ziplist编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个节点则保存元素的分值。对于skiplist编码实现，它同时内部包含一个字典和跳跃表，程序都可以用O(log(N))的复杂度往集合中添加成员，并可以用O(1)的复杂度查找给定成员的分值。

**18、Redis为什么用skiplist而不用平衡树。**

Redis里面使用跳跃表skiplist实现sorted set有序集合（实际上还有散列表），而没有采用红黑树、平衡树这种结构。原因主要有以下几点：

- 跳表使用空间换时间的设计思路，通过构建多级索引来提高查询的效率，实现了基于链表的“二分查找”。
- 跳表是一种动态数据结构，支持快速的插入、删除、查找操作，时间复杂度都是 O(logn)。并且范围查找比红黑树高效。跳表的空间复杂度是 O(n)。不过，
- 跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。虽然跳表的代码实现并不简单，但是作为一种动态数据结构，比起红黑树来说，实现要简单多了。所以很多时候，我们为了代码的简单、易读，比起红黑树，我们更倾向用跳表。

参考文章：[跳表：为什么Redis一定要用跳表来实现有序集合？](https://blog.csdn.net/z69183787/article/details/89396748)

**3、Redis的使用要注意什么，Redis优化**

- 使用简短的key。
- 大的数据压缩后再存入value。
- 将多个指令合并，例如多个get合并成megt，hget，避免多次创建TCP连接，TCP头，IP头，帧头，这些额外数据会浪费内存。
- 采用连接池jedispool，复用连接。
- 设置key有效期。
- 选择回收策略。当 Redis 的实例空间被填满了之后，将会尝试回收一部分key。在Redis中，允许用户设置最大使用内存大小server.maxmemory，当Redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略，有很多不同的回收策略。
- 在服务器端使用Lua脚本。

**4、Redis的事务性。**

Redis通过MULTI、EXEC、WATCH等命令来实现事务（transaction）功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕后，然后才去处理其他客户端的命令请求。

事务的生命周期为：

- 事务开始：使用MULTI开启一个事务（自己项目中，采用jedis.multi()来返回一个事务Transaction，后续可以在此事务上进行操作）
- 命令入队：在开启事务的时候，每次操作的命令将会被插入到一个队列中，同时这个命令并不会被真的执行。
- 事务执行：EXEC命令进行提交事务

Redis事务具有的性质：

- 单独的隔离操作：事务中所有命令都会被序列化、按顺序执行，在执行过程中不会被其他客户端发送来的命令打断。
- 没有隔离级别的概念：队列中的命令在事务没有被提交之前不会被实际执行。

在Redis中，事务总是具有原子性、一致性和隔离性。当Redis运行在某种特定的持久化模式（开启AOF和RDB服务）下时，事务也具有持久性。

着重讲一下原子性。

对于Redis的事务功能来说，事务队列中的命令要么就全部执行，要不就一个都不执行。从这点来说，事务具有原子性。但这个执行失败的条件是指**命令入队出错**（比如命令不存在，格式不正确等情况）而被服务器拒绝执行，而不是命令实际执行时出错。

Redis的事务与传统的关系式数据库事务的最大区别在于，Redis不支持事务回滚机制（rollback），即使事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕为止。
一定注意，Redis的事务性与常见的关系式数据库有些不同（尤其原子性），建议直接去看《Redis设计与实现》的19.3小节-事务的ACID性质，网上各种博客说的参差不齐。



**6、Memcache的原理，哪些数据适合放在缓存中。**

Memcache采用键值对存储方式。它本质是一个大的 hash表，key的最大长度为255个字符，最长过期时间为30天。它的内存模型如下：Memcache预先将可支配的内存空间进行分区（Slab），每个分区里再分为多个块（Chunk）最大1M，但同一个分区中块的大 小是固定的。然后，插入数据时，会根据数据大小寻找最合适的块，然后插入，当然这样也就会有部分内存浪费，但可一定程度上减少内存碎片，总体上，利大于弊。

应用场景主要是分布式应用，数据库前段缓存和服务期间数据共享等。

**7、Redis相比memcached有哪些优势？两者的主要区别？**

- memcached所有的值均是简单的字符串，Redis作为其替代者，支持更为丰富的数据类型
- Redis的速度比memcached快很多
- Redis可以持久化其数据
- Redis支持数据的备份，即master-slave模式的数据备份。

**8、Redis的并发竞争问题如何解决，了解Redis事务的CAS操作吗？**

例子：两个客户端都要给同一个key的value + 1。两个客户端均要先获取key和value再加1，那么如果两个客户端都是先获取值再+1，最后value只加了一次而不是两次，发生了线程安全问题。
- 使用watch+事务：WATCH命令就是一个乐观锁，它可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否被修改了，如果被修改了整个事务会回滚，并向客户端返回空。如果连接断开，监视和事务都会被自动清除。

参考连接：[redis的高级事务CAS(乐观锁)](https://www.cnblogs.com/martinzhang/p/3415204.html) 和 [Redis实现CAS的乐观锁](https://www.jianshu.com/p/d777eb9f27df)

**9、Redis适合于哪些场景。**

- Session共享（单点登陆）
- 页面缓存
- 队列（比如项目中用到的异步队列）
- 排行榜/计数器
- 发布/订阅（实现消息流）

**10、Redis持久化的机制，AOF和RDB的区别。**

Redis提供两种方式进行持久化，一种是RDB持久化（会按照配置的指定时间将内存中的数据快照到磁盘中，创建一个dump.rdb文件，Redis启动时再恢复到内存中），另一种是AOF持久化（以日志的形式记录每个写操作（读操作不记录），只需追加文件但不可以改写文件，Redis启动时会根据日志从头到尾全部执行一遍以完成数据的恢复工作）。当AOF过大时，会进行AOF优化，去掉无用的指令。

***RDB***
通过配置文件配置快照生成频率：
- save 900 1:如果900s发生一次修改，生成快照。
- save 300 10:如果300s发生10次修改，生成快照。
- save 60 10000:如果60s发生10000次修改，生成快照。

通过bgsave/save命令手动生成RDB快照。

***AOF***
每个AOF指令都会写入磁盘中，appendfsync控制AOF写入频率：
no：不进行同步，直接向客户端返回。
always：进行同步，客户端等待写入成功才返回，效率较低。
everysec：每秒同步一次。

两者的区别在于：

- RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，fork子进程共享父进程的快照。先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。一旦持久化前宕机，RDB快照保存失败，期间的数据全部丢失。
- AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。

需要注意的是，默认情况下，Redis选用的是快照RDB的持久化方式，将内存中的数据以快照的方式写入二进制文件中，默认的文件名为dump.rdb。

RDB方式不能完全保证数据持久化，因为是定时保存，所以当redis服务down掉，就会丢失一部分数据，而且数据量大，写操作多的情况下，会引起大量的磁盘IO操作，会影响性能。所以，当RDB和AOF方式都开启的情况下，服务器会优先使用AOF文件来还原数据库状态，当然，AOF恢复数据速度要慢一些。

还一点需要注意，服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止。

**Redis如何处理过期数据**
- 惰性删除：使用到key时，才查看key是否过期。
- 定期删除：周期性地随机测试一批key是否过期。

还一点需要注意，服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止。

**11、Redis对象的内存回收。**

Redis在自己的对象系统中构建了一个引用计数技术实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。

每个对象的引用计数信息是由redisObject结构的refcount属性记录。与jvm中的应用计数法很相似，不在赘述。

Redis对象在整个生命周期可以划分为创建对象、操作对象、释放对象三个阶段。

**12、Redis数据淘汰策略。**

Redis提供了五种数据淘汰策略：

- volatile-lru：使用LRU算法进行数据淘汰（淘汰上次使用时间最早的，且使用次数最少的key），只淘汰设定了有效期。
- volatile-ttl：淘汰剩余有效期最短的key。
- volatile-random：随机淘汰数据，只淘汰设定了有效期的key。
- allkeys-random：随机淘汰数据，所有的key都可以被淘汰。
- allkeys-lru：使用LRU算法进行数据淘汰，所有的key都可以被淘汰。


此外，如果不设置如上策略的话，还有一种noeviction策略，当内存限制达到，谁也不删除，返回错误。


**5、当前Redis 集群有哪些方式，各自优缺点，场景。**

-以前的redis高可用：
--以前只用一个master，多个slave，master写，slave读。通过哨兵（占一个单独结点），每2s心跳检测，当master挂掉后，通过slave的优先级选举一个slave作为master。有10秒时间，redis不能服务。

-现在的reids高可用：

--redis cluster中没有哨兵。cluster有多个master，每个master有若干slave。当一个master挂掉，选举一个slave作为master。
--基于分片的方式工作：多个master之间不需要同步数据，每个master有槽位的概念，槽位有16384个。每个master平均分配若干槽位。将插入的key取出hash%16386后，得到的值就是槽位，放到指定槽位的master中。

cluster扩容：

hash槽重新分配和key进行转移。

总结：
- 数据共享：Redis提供多个节点实例间的数据共享，也就是Redis A、B、C、D彼此之间的数据是同步的，同样彼此之间也可以通信，而对于客户端操作的keys是由Redis系统自行分配到各个节点中。
- 主从复制：Redis的多个实例间通信时，一旦其中一个节点故障，那么Redis集群就不能继续正常工作了，所以需要一种复制机制（Master-Slave）机制，做到一旦节点A故障了，那么其从节点A1和A2就可以接管并继续提供与A同样的工作服务。
- 哈希槽值：Redis集群中使用哈希槽来存储客户端的keys，而在Redis中，目前存有16384（2的14次方）个哈希槽，它们被全部分配给所有的节点。



参考链接：[Redis集群使用总结（一）](https://www.cnblogs.com/RENQIWEI1995/p/8931678.html)


**13、Redis的主从复制机制原理。**




主从的意义：

- redis要达到高可用、高并发，只有单个redis是不够的，单个redis也就只能支持几万的QPS，所以必须以集群的形式提供服务，而集群中又以多个主从组成。
- 主从是以多个redis集合在一起，以一个master多个slave为模式对外提供服务，master主要以写为主，slave提供读，即是读写分离的情况，以读多写少为准，如果写比较多的情况一般就以异步的形式提供服务。

主从复制功能分为两个阶段：


Redis 的复制分为全量同步和增量同步。
- 全量复制：将Redis的所有数据从master复制到slave中。
- 增量复制：从master中复制slave所缺少的数据。

Redis 在进行全量同步时，master 会将内存数据通过 bgsave 落地到 rdb，同时，将构建 内存快照期间 的写指令，存放到复制缓冲中，当 rdb 快照构建完毕后，master 将 rdb 和复制缓冲队列中的数据全部发送给 slave，slave 完全重新创建一份数据。

这个过程，对 master 的性能损耗较大，slave 构建数据的时间也比较长，而且传递 rdb 时还会占用大量带宽，对整个系统的性能和资源的访问影响都比较大。

而增量复制，master 只发送 slave 上次复制位置之后的写指令，不用构建 rdb，而且传输内容非常有限，对 master、slave 的负荷影响很小，对带宽的影响可以忽略，整个系统受影响非常小。


**14、Redis的线程模型是什么。**

Redis基于Rector模型开发了自己的文件事件处理器（file event handler）：

- 文件事件处理器使用I/O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。
- 当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。

虽然文件事件处理器以单线程方式运行，但通过与I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性。



**16、分布式使用场景（存储session）。**

还没遇到过

**17、怎么保证缓存和数据库的一致性。**

只要用缓存，就可能会涉及到缓存与数据库双存储双写，只要是双写，就一定会有数据一致性的问题。

一般来说，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是说如果你的系统不是严格要求 “缓存+数据库” 必须保持一致性的话，最好不要做这个方案，即：读请求和写请求串行化，串到一个内存队列里去。

串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上请求。

**最经典的缓存+数据库读写的模式，就是Cache Aside Pattern。**

- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后返回缓存，同时返回响应。
- 更新的时候，先更新数据库，然后再删除缓存。

为什么是删除缓存，而不是更新缓存呢。原因有二，一是在复杂缓存场景中，缓存不单单是数据库中直接取出来的值；二是更新缓存的代价是很高的。举个例子，一个缓存涉及的表的字段，在 1 分钟内 就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有大量的冷数据。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低，用到缓存才去算缓存。

其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。

在这个读写模式下，也会出现数据不一致问题。

**最初级的数据不一致问题分析:**

问题：先修改数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。

解决方案：先删除缓存，再修改数据库。必须等到缓存删除成功时再更新数据库，两个数据源都是新数据；如果删除失败，则不进行数据库更新，这样数据源都是旧的。解决了数据不一致问题。这样可以防止改完了数据库后，删除缓存失败，导致缓存不一致的问题。


**比较复杂的数据不一致问题分析:**

问题：数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中。随后数据变更的程序完成了数据库的修改。在这个场景下，数据库和缓存中的数据不一样了。

针对这个方法有一种解决方案，叫做**延时双删策略**。伪代码如下：

```java
public void write(String key,Object data){
redis.delKey(key);
db.updateData(data);
Thread.sleep(1000);
redis.delKey(key);
}
```

转换为中文描述为：

- 先淘汰缓存。
- 再写数据库（这两步与原来一样）。
- 休眠一秒，再次淘汰缓存。这样做可以将1秒内所造成的缓存脏数据再次删除。

其他主要的队列解决方案：

- 更新数据的时候，根据数据的唯一标识，将数据操作请求，发送到一个 jvm 内部队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也发送同一个 jvm 内部队列中。
- 一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新。此时如果一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。
- 这里有一个优化点，一个队列中，其实多个更新缓存请求串在一起是没意义的，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可。

在这个方法下，需要注意读缓存请求超时问题，每个读请求必须在超时时间内返回。如果超时还未读到更新后缓存的话，则直接从数据库读旧的值。

另外，保持读写一致性还可以用其他方法来做。比如**MySQL读写分离，或者Redis分布式锁**。

参考文章：[一个高频面试题：怎么保证缓存与数据库的双写一致性？](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487406&idx=1&sn=29001c51362db626b31153d020ea7c09&chksm=fa49701fcd3ef90956edbbda056d1464681c17e57ec8ba1501356e1cc3f8efb25e1b302e7eb9&scene=0&xtrack=1&key=32c60e053085a25ac01d3ce21a0647c93bd6d6f8b103810d2362e2b0199027c468fe8b3573ed8459bf3b563144d7160f5024f17e5fe8ce409f1bbd6b0d47b4302d2ad9f79a26fe6ed22adf2bc8576ad2&ascene=1&uin=MjQ3MzkwMTc2Mw==&devicetype=Windows+10&version=62060833&lang=zh_CN&pass_ticket=8XpPIyMMLiCzCMbxmqfGQpreQccYQb60+6UwOsqsnbYwpIBCzsx3Ne16bvnrqbXg)


**19、Redis分布式锁的实现方式。**

Redis分布式锁实现方式有以下几种。

**第一种，使用redis的watch命令进行实现。**

watch指令在redis事物中提供了CAS的行为。为了检测被watch的keys在是否有多个clients同时改变引起冲突，这些keys将会被监控。如果至少有一个被监控的key在执行exec命令前被其他客户端修改，整个事务将会回滚，不执行任何动作，从而保证原子性操作，并且执行exec会得到null的回复。

具体工作机制：watch 命令会监视给定的每一个key，当exec时如果监视的任一个key自从调用watch后发生过变化，则整个事务会回滚，不执行任何动作。注意watch的key是对整个连接有效的，事务也一样。如果连接断开，监视和事务都会被自动清除。

[watch代码详解](https://www.cnblogs.com/justuntil/p/10539866.html)

**第二种，使用redis的setnx命令进行实现。**

先看一下这个相关的命令。

```sql
SETNX key value
```

如果key不存在，就设置key对应字符串value。在这种情况下，该命令和SET一样。当key已经存在时，就不做任何操作。SETNX是”SET if Not eXists”。

```SQL
expire KEY seconds
```

设置key的过期时间。如果key已过期，将会被自动删除。

```SQL
del KEY
```

删除key

由于当某个key不存在的时候，SETNX才会设置该key。且由于Redis采用单进行单线程模型，所以，不需要担心并发问题。那么，就可以利用SETNX的特性维护一个key，存在的时候，即锁被某个线程持有；不存在的时候，没有线程持有锁。

并且还可以设置key的过期时间当作锁的超时时间，释放锁就直接可以将key删除即可。

**20、Redis遇到的问题和缺点。**

- Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者切换数据库才能恢复。
- Redis主从复制过程中，第一个步骤是同步，需要采用全量复制，复制过程中主机会fork出一个子进程对内存做一份快照，并将子进程的内存快照保存为文件发送给从机，这一过程需要确保主机有足够多的空余内存。若快照文件较大，对集群的服务能力会产生较大的影响。
- Redis作为缓存的话，还会出现缓存和数据库双写一致性的问题。

**23、Redis哈希槽的概念。**

Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。

**24、Redis的缓存雪崩。**

缓存雪崩，简单的理解就是：由于原有缓存失效（或者数据未加载到缓存中），新缓存未到期间（缓存正常从Redis中获取），所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机，造成系统的崩溃。对此，基本的解决思路有：

- 考虑采用加锁或者队列的方式保证不会同时有大量的线程对数据库一次性进行读写，避免缓存失效时对数据库造成太大的压力，虽然能够一定的程度上缓解了数据库的压力，但是也降低了系统的吞吐量。
- 分析用户的行为，不同的key设置不同的过期时间，尽量让缓存失效的时间均匀分布。
- 做二级缓存，或者双缓存策略。A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期。

具体方法如下：

- 事发前：实现Redis的高可用(主从架构+Sentinel 或者Redis Cluster)，尽量避免Redis挂掉这种情况发生。[cluster](https://my.oschina.net/u/3764456/blog/3118396)
- 事发中：万一Redis真的挂了，我们可以设置本地缓存(ehcache)+限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)
- 事发后：redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。

**25、Redis的缓存穿透。**

缓存穿透是指用户查询数据时，在数据库中没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库中查询。查询一个必然不存在的数据。比如文章表，查询一个不存在的id，每次都会访问DB，如果有人恶意破坏，很可能直接对DB造成影响。对此，基本的解决思路有：

- 如果查询数据库为空，直接设置一个默认值存放到缓存中，这样第二次缓存中获取就有值了，而不会继续访问数据库，这种方法最简单粗暴。
- 根据缓存数据key的规则进行过滤，比如说缓存Key为mac地址。这就要求key必须有以顶的规则，这种方法可以缓解一部分的压力，但是无法根治。
- 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的BitSet中，对于一个key，使用多个hash函数进行映射，得到多个值，将这些值作为下标，下标对应的bit数组置为1。只有当key的所有hash函数的下标对应的元素为1时，才表明数据库中可能有该数据，不一定有，因为可能存在hash重叠。如果某个hash值对应的元素为0，则数据库中一定没有该元素。如果布隆过滤器表示数据库没有这个值，就不查。
[布隆过滤器](https://www.cnblogs.com/happydreamzjl/p/11834277.html)
[详细布隆过滤器](https://www.cnblogs.com/luxianyu-s/p/12686466.html)

具体方法如下：

由于请求的参数是不合法的(每次都请求不存在的参数)，于是我们可以使用布隆过滤器(BloomFilter)或者压缩filter提前拦截，不合法就不让这个请求到数据库层！

当我们从数据库找不到的时候，我们也将这个空对象设置到缓存里边去。下次再请求的时候，就可以从缓存里边获取了。这种情况我们一般会将空对象设置一个较短的过期时间。


