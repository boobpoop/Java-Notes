# 2020届秋招面试题总结——JVM篇

**1、JVM的内存结构，Eden和Survivor比例。**

![Y4UgeO.png](https://s1.ax1x.com/2020/05/19/Y4UgeO.png)

Java虚拟机在执行Java程序的过程中把它所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。

- 程序计数器。当前线程执行的字节码的行号指示器，是线程私有的。也是唯一一个不会发生内存溢出的区域。
- Java虚拟机栈。也是线程私有的，描述的是Java方法执行的内存模型，存放局部变量表，操作数栈，线程内一个方法就是一个栈帧，调用方法，实际上是栈帧入栈；方法结束，实际上是栈帧出栈。线程请求的栈深度大于虚拟机所允许的最大深度，则将抛出StackOverflowError异常。
- 本地方法栈。与虚拟机栈相似，区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。
- Java堆。是Java虚拟机中管理的内存中最大的一块，所有线程共享区域，唯一目的就是存放对象实例。所有的对象实例以及**数组**都要在堆上分配内存。Java堆也是垃圾回收器管理的主要区域，也被称为gc堆，收集器基本都采用分代收集算法，Java堆中还可以细分为：新生代和老年代，新生代又分为Eden区和Surivor区。
- 方法区。方法区是一种内存规范，java8中方法区的具体实现是元空间。元空间使用直接内存，非虚拟机管辖范畴，这样元空间不会发生内存溢出。是线程共享区域，用于存储类的方法代码，变量名，方法名，访问权限，返回值等数据。注意Class对象放在堆中。java8中方法区的运行时常量池在堆中。是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。
- 直接内存。并不是虚拟机运行时数据区的一部分。例如NIO，它可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样避免了在Java堆和Native堆中来回复制数据，提高了性能。

JVM中要对堆进行分代，分代的理由是优化GC性能。80%的对象存活时间很短，20%对象存活时间很长。因此分为年轻代和老年代，年轻代存放刚创建不久的对象，如果对象存活时间很长，那么就将对象放入老年代后者那个。年轻代垃圾产生较频繁，gc次数较多；老年代垃圾不够频繁，gc次数较少，可以节省无意义的gc。

HotSpot JVM把新生代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。

因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。

**2、jdk1.8的虚拟机中内存模型变化。**

在jdk1.8中变化最大的是取消了永久区Perm，而是用元数据空间Metaspace来进行替换。需要注意的是，元空间占用的内存不是虚拟机内部的，而是本地内存空间，当然也不是堆内存。这个变化的理由如下：

- 在jdk1.8之前的HotSpot实现中，类的元数据如方法数据、方法信息（字节码、栈和变量的大小）、运行时常量池等保存在永久代。32位默认永久代为64M，64位默认85M，可以通过参数-XX：MaxPermSize进行设置，一旦类的元数据超过了永久代的大小，就会抛出OOM异常了。
- 对永久代的调优过程很困难，因为永久代的大小很难确定，其中涉及到很多因素，如类的总数、常量池大小和方法数量等，而且永久代的护具可能会随着每一次Full GC而发生移动。
- 在jdk1.8中，类的元数据保存在本地内存中，元空间的最大可分配空间就是系统可用内存空间。

**3、什么情况下会发生栈内存溢出。**

在HotSpot虚拟机中是将虚拟机栈和本地方法栈合二为一，栈是线程私有的，它的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈桢在虚拟机栈中入栈到出栈的过程。本地方法栈与虚拟机栈相似，区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。

1. 栈内存溢出是指线程请求的栈深度大于虚拟机所允许的最大深度，则将抛出StackOverflowError异常（StackOverflowError 不属于 OOM 异常）。最有可能的原因就是方法递归产生的这种结果。

2. 另一个可能是引用了大的变量，在拓展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常（这个属于内存溢出）。

（这两个异常本质上是同一个异常。因为在JVM的参数设置中只有-Xss这一个参数是设置栈区大小的，也就是它并没有额外指定单个线程所能使用的最大栈容量。换句话说，虚拟机所允许的最大栈深度就是虚拟机当前剩余的栈区大小。那么当出现栈内存异常的时候，你即可以说它是由于线程请求的栈深度大于虚拟机所允许的最大深度而引起的异常；也可以说是虚拟机在扩展栈时无法申请待足够的内存空间而引起的异常。）

**3、JVM内存为什么要分成新生代、老年代。新生代中为什么要分Eden和Survivor。**

堆内存是虚拟机管理的内存中最大的一块，也是垃圾回收最频繁的一块区域，我们程序所有的对象实例都存放在堆内存中。给堆内存分代是为了提高对象内存分配和垃圾回收的效率。试想一下，如果堆内存没有区域划分，所有的新创建的对象和生命周期很长的对象放在一起，随着程序的执行，堆内存需要频繁进行垃圾收集，而每次回收都要遍历所有的对象，遍历这些对象所花费的时间代价是巨大的，会严重影响我们的GC效率，这简直太可怕了。

有了内存分代，情况就不同了，新创建的对象会在新生代中分配内存，经过多次回收仍然存活下来的对象存放在老年代中，静态属性、类信息等存放在永久代中，新生代中的对象存活时间短，只需要在新生代区域中频繁进行GC，老年代中对象生命周期长，内存回收的频率相对较低，不需要频繁进行回收，永久代中回收效果太差，一般不进行垃圾回收，还可以根据不同年代的特点采用合适的垃圾收集算法。分代收集大大提升了收集效率，这些都是内存分代带来的好处。

 HotSpot将新生代划分为三块，一块较大的Eden空间和两块较小的Survivor空间，默认比例为8：1：1。划分的目的是因为HotSpot采用复制算法来回收新生代，设置这个比例是为了充分利用内存空间，减少浪费。新生成的对象在Eden区分配（大对象除外，大对象直接进入老年代），当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。
 
 Survivor区相当于Eden区和老年代的16级缓冲。

**4、JVM中一次完整的GC流程是什么样子的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。**

GC开始时，对象只会存在于Eden区和From Survivor区，To Survivor区是空的（作为保留区域）。GC进行时，Eden区中所有存活的对象都会被复制到To Survivor区，而在From Survivor区中，仍存活的对象会根据它们的年龄值决定去向，年龄值达到年龄阀值（默认为15，新生代中的对象每熬过一轮垃圾回收，年龄值就加1，GC分代年龄存储在对象的header中）的对象会被移到老年代中，没有达到阀值的对象会被复制到To Survivor区。接着清空Eden区和From Survivor区，新生代中存活的对象都在To Survivor区。接着， From Survivor区和To Survivor区会交换它们的角色，也就是新的To Survivor区就是上次GC清空的From Survivor区，新的From Survivor区就是上次GC的To Survivor区，总之，不管怎样都会保证To Survivor区在一轮GC后是空的。GC时当To Survivor区没有足够的空间存放上一次新生代收集下来的存活对象时，需要依赖老年代进行分配担保，将这些对象存放在老年代中。

对象晋升老年代有三种可能：

- 当对象达到成年，经历过15次GC（默认是15，可配置），对象就晋升到老年代了。
- 大的对象会直接在老年代创建。
- 新生代的Survivor空间内存不足时，对象可能直接晋升到老年代。

jvm参数：

- -Xms：初始堆大小
- -Xmx：堆最大内存
- -Xss：栈内存
- -XX:MetaspaceSize 初始元空间内存
- -XX:MaxMetaspaceSize 最大元空间内存

**5、你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。**

常见的垃圾收集器主要有以下四种：

- 串行收集器（Serial、ParNew收集器）：单个线程垃圾收集。年轻代采用复制算法（单线程执行完）；老年代采用标记整理算法（单线程执行完）。简单高效，但它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束，中间停顿时间长。
- 并行收集器（Parallel Scavenge收集器）：多线程并行进行年轻代的垃圾收集，单线程执行老年代的垃圾收集。并行收集器吞吐量优先，主要关注点在于精确控制吞吐量，即减少GC停顿时间，但收集次数变多。但有时候，垃圾突然变多，根据设计的吞吐量，垃圾还没收集完，gc就结束了，垃圾会遗留到下次，这会使收集次数变多。吞吐量设计：

"-XX:MaxGCPauseMillis"：控制最大垃圾收集停顿时间。
"-XX:GCTimeRatio"： 垃圾收集执行时间占应用程序执行时间的比例。

- CMS：采用标记-清除的垃圾收集算法。CMS运行分四个步骤:

初始标记:仅仅只是标记一下GC Roots能直接关联到的对对象，速度很快，需要停顿。

并发标记:进行行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。和用户线程一起工作。

重新标记:为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对标的标记记录，不需要停顿。

并发清除:不需要停顿。和用户线程一起工作。

CMS缺点：

无法处理浮动垃圾，可能出现在并发清除的过程中，用户线程在产生垃圾，这些垃圾只能下次GC时清理，被成为浮动垃圾。因此JVM要预留一部分内存存储浮动垃圾。同时标记 - 清除算法导致的内部碎片，小内存往往无法使用。

- G1：采用标记-整理的垃圾收集算法。主要步骤分为，初始标记，并发标记，最终标记和筛选回收。前三步和CMS一样，但是第四步的清理工作需要停顿。G1把堆划分成为大小相同的独立区域，新生代和老年带不再物理隔离。注意：CMS是清除，所以会存在很多的内存碎片。G1是整理，所以碎片空间较小。

G1和CMS都是响应优先，他们的目的都是尽量控制stop the world的时间。

CMS在并发清除时，不需要停顿，而G1需要停顿。但是CMS会产生浮动垃圾和内存碎片，g1不会。因此CMS适用于高并发对时间要求高的，而g1适用于要求系统稳定的，即内存管理完善的。

**6、垃圾回收算法的实现原理。**

垃圾收集算法主要分为以下三种：

- 标记-清除算法：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。会产生内部碎片。
- 复制算法：将可用内存按容量分为两块（Eden和Survivor空间），每次只使用一块，当这一块内存用完后，就将还活着的对象复制到另外一块上面，然后再把已使用过内存空间一次清理掉。
- 标记-整理算法：标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界外的内存。

**7、当出现了内存溢出，怎么排错。**

- 首先控制台查看错误日志，进行简单的排查。
- 如果是堆溢出，就使用jmap命令创建堆快照，使用jdk自带的VisualVM来查看快照信息。查看堆中是否创建老超大的对象。
- 如果是栈内存溢出，就使用jstack创建栈快照，使用jdk自带的VisualVM来查看快照信息。看是栈中是否创建了超大的对象，或者递归调用。

**8、JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。**

JVM内存模型是指多级缓存模型。多级缓存模型是通过高速缓冲存储内存中的数据。每个线程有自己独有的工作内存空间，它们共享主内存的数据。但是多线程会导致线程安全问题。

重排序是指编译器为了充分利用处理器而对指令序列进行重新排序的一种手段。例如，一个耗时时间长的指令可能会重排序到耗时短的指令的后面，这样可以让耗时短的指令先执行。

内存屏障是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。

happen-before用来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。具体原则如下：

- 程序次序法则：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都能出现在A之后。
- 监视器锁法则：对一个监视器锁的解锁 happens-before于每一个后续对同一监视器锁的加锁。
- volatile变量法则：对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。
- 线程启动法则：在一个线程里，对Thread.start的调用会happens-before于每个启动线程的动作。
- 线程终结法则：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回，或Thread.isAlive返回false。
- 中断法则：一个线程调用另一个线程的interrupt happens-before于被中断的线程发现中断。
- 终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。
- 传递性：如果A happens-before于B，且B happens-before于C，则A happens-before于C。

主内存是指所有线程共享的内存空间。

工作内存是指每个线程特有的内存空间。工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写在主内存中的变量。

参考链接：[JVM内存模型、指令重排、内存屏障概念解析](https://www.cnblogs.com/chenyangyao/p/5269622.html)

**10、你们线上应用的JVM参数有哪些。**

- -Xms512m //初始堆大小
- -Xmx1024m //最大堆大小
- -XX:PermSize=640m //设置持久代初始值
- -XX:MaxPermSize=1280m //设置持久代最大值
- -XX:NewSize=64m //设置年轻代初始值
- -XX:MaxNewSize=256m //设置年轻代最大值
- -XX:+PrintGCDetails //日志输出形式
- -XX:+PrintGCTimeStamps //日志输出形式

在默认情况下，JVM初始分配的堆内存大小是物理内存的1/64，最大分配的堆内存大小是物理内存的1/4。

默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。

因此服务器一般设置-Xms、-Xmx相等，来避免每次GC后调整堆的大小。


**12、怎么打印线程栈信息。**

```java
StackTraceElement[] elements = (new Throwable()).getStackTrace();
StringBuffer buf = new StringBuffer();
for(int i=0; i<elements.length; i++) {
    buf.append("\n"
            + elements[i].getClassName()//打印线程当前执行的详细类名
            + "."
            + elements[i].getMethodName()//打印线程当前方法名
            + "("
            + elements[i].getFileName()//打印线程当前执行类的文件名
            + ":"
            + elements[i].getLineNumber()//打印线程当前执行的行数
            + ")");
}
```

**13、请解释如下jvm参数的含义。**

- -server：服务器模式
- -Xms512m：初始堆空间
- -Xmx512m：最大堆空间
- -Xss1024K：栈空间
- -XX:PermSize=256m：初始永久代空间
- -XX:MaxPermSize=512m ：最大永久代空间
- -XX:MaxTenuringThreshold=20：在新生代对象存活次数（经历Minor GC的次数）后依旧存活，就会晋升到老年代。
- -XX:CMSInitiatingOccupancyFraction=80 ：设定CMS在对老年代内存占用率达到80%的时候开始GC(因为CMS会有浮动垃圾,所以一般都较早启动GC)。
- -XX:+UseCMSInitiatingOccupancyOnly：只是用设定的回收阈值(上面指定的80%),如果不指定,JVM仅在第一次使用设定值,后续则自动调整.

**14、Java中对象创建的几种方式。**

创建对象的方式有四种：

- 用new关键字创建。

```java
User user = new User();
```

- 调用对象的clone方法（实现Clonable接口）。

- 利用反射，调用Class类的或者是Constructor类的newInstance（）方法。

```java
User user = User.class.newInstance();
```

或者是

```java
Constructor<User> constructor =User.class.getConstructor();
User user= constructor.newInstance();
```

- 用反序列化，调用ObjectInputStream类的readObject（）方法。

**15、Java中的对象一定在堆上分配内存吗？**

JIT编译器做了很多优化，其中一个优化就是逃逸分析。如果一个对象被分析出来一定逃不出这个这个方法，那就把堆分配转换成栈分配。

参考文章：[深入理解Java中的逃逸分析](https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650121615&idx=1&sn=00d412f68fe58dceab6d13fdfefac113&chksm=f36bb8aec41c31b8d62069e2663345c0452ebdded331616496637e19b2cad72725f6ce90daec&scene=21#wechat_redirect) 和 [对象并不一定都是在堆上分配内存的](https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650121307&idx=1&sn=5526473d0248cca8385d2a18ba6b25af&chksm=f36bb97ac41c306c354ebf0335cd2fd77cac03f3434894e4e5b44a01754a5494b04350d26d14&scene=21#wechat_redirect)

**16、运行时数据中哪些区域是线程共享的，哪些是独享的。**

在JVM运行时内存区域中，程序计数器、虚拟机栈和本地方法栈是线程独享的。而Java堆、方法区是线程共享的。但是值得注意的是，Java堆其实还为每一个线程单独分配了一块TLAB空间（本地线程分配缓冲），这部分空间在分配时是线程独享的，在使用时是线程共享的。（[TLAB介绍](https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650124457&idx=1&sn=1c33947700dfb28048df4a913b434077&chksm=f36bad88c41c249ea854b371a1c8597959e2e35c2890bdd6a5945df0b568bdfc980d1dd2cf2b&scene=21#wechat_redirect)）

创建对象时，内存分配过程如何保证线程安全性？有两种解决方案：

- 对分配内存空间的动作做同步处理，采用CAS机制，配合失败重试的方式保证更新操作的线程安全性。
- 每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块"私有"内存中分配，当这部分区域用完之后，再分配新的"私有"内存。**这个本地线程分配缓冲就叫做TLAB。**

**17、Java中数组是存储在堆上还是栈上。**

在Java中，数组同样是一个对象，所以对象在内存中如何存放同样适用于数组；

所以，数组的实例是保存在堆中，而数组的引用是保存在栈上的。

**18、Java对象创建的过程是怎么样的。**

对于一个普通的Java对象的创建，大致过程如下：

1. 虚拟机遇到new指令，到常量池定位到这个类的符号引用。
2. 检查符号引用代表的类是否被加载、解析、初始化过 ，如果没有的话，则执行相应的类加载过程。
3. 虚拟机为对象分配内存。 根据Java内存是否规整，分别通过“指针碰撞”或“空闲列表”来分配。
4. 执行方法，成员变量进行初始化。

**19、怎么获取堆和栈的dump文件。**

Java Dump，Java虚拟机的运行时快照。将Java虚拟机运行时的状态和信息保存到文件。

可以使用在服务器上使用jmap命令来获取堆dump，使用jstack命令来获取线程的调用栈dump。

参考文章：[Java命令学习系列（二）——Jstack](https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=402296484&idx=1&sn=8e7fc8197a216afb590b17e15f9b721e&chksm=796493854e131a932b3dd53839820eaba022cb87a601062b6bf6a574d742cd8e92a707432173&scene=21#wechat_redirect) 和  [Java命令学习系列（三）——Jmap](https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=402312019&idx=1&sn=97736feb967ecbffb454fa037015ad6d&chksm=7964d6724e135f64a5c0d65e41afbeac45700dd91149375f99071731954e855e13b11cd6c30b&scene=21#wechat_redirect)

**20、Minor GC和Full GC的触发条件。**

Minor GC触发条件：当Eden区满时，触发Minor GC。只有一个条件。

Full GC触发条件：

- 调用System.gc时，系统建议执行Full GC，但是不必然执行。
- 老年代空间不足。
- concurrent mode failure，当执行CMS GC过程时（“标记-清除”，存在内存碎片），同时有对象要放入老年代，而此时老年代空间不足造成的（有时候“空间不足”是CMS GC时当前的浮动垃圾过多导致暂时性的空间不足触发Full GC）。

**21、在Java语言中，可以作为GC Roots的对象有什么。**

可作为GC Roots的对象包括以下几种：

- 虚拟机栈（栈桢中的本地变量表）中引用的对象。
- 元空间中类静态属性引用的对象。
- 元空间中常量引用的对象。
- 本地方法栈中JNI（即一般说的Native方法）引用的对象。

获取GC Roots最主要的部分在解决如果快速找到JVM栈的栈桢的局部变量表中的局部变量所引用的对象。大致思路是JVM采用了**OopMap**这个数据结构记录了GC Roots，GC的标记开始的时候，直接用OopMap就可以获得GC Roots。OopMap记录了特定时刻栈上（内存）和寄存器（CPU）的哪些位置是引用，通过这些引用就可以找到堆中的对象，这些对象就是GC Roots，而不需要一个一个的去判断某个内存位置的值是不是引用。


即使可达性算法中不可达的对象，也不是一定要马上被回收，还有可能被抢救一下。
1.可达性分析后没有发现引用链。
2.查看对象是否有finalize方法，如果有重写且在方法内完成自救,比如再建立引用，还是可以抢救一下，注意这边一个类的finalize只执行一次，这就会出现一样的代码第一次自救成功第二次失败的情况。如果类重写finalize且还没调用过，会将这个对象放到一个叫做F-Queue的序列里，这边finalize不承诺一定会执行，这么做是因为如果里面死循环的话可能会时F-Queue队列处于等待，严重会导致内存崩溃，这是我们不希望看到的。

**22、类加载过程。**

Java虚拟机中类加载的全过程包括：加载、验证、准备、解析和初始化这5个阶段。

**加载:**

在加载阶段，虚拟机主要完成以下3个事情。

- 通过一个类的全限定名来获取定义此类的二进制字节流。（这一步骤就是通过类加载器来实现的）
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各类数据的访问入口。

**验证:**

验证时连接阶段的第一步，这一阶段的目的是为了**确保Class文件的字节流中包含的信息符合当前虚拟机的要求**，并且不会危害虚拟机自身的安全。

- 文件格式验证：验证字节流是否符合Class文件格式的规范，包括文件头部的魔数因子、class文件主次版本号、class文件的MD5指纹等。
- 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范。简单来说就是验证Java语法的正确性。
- 字节码验证：主要验证程序的控制流程，如循环、分支等。

**准备:**

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在**方法区**中分配。需要注意的是，这时候进行内存分配的仅包括**类变量（被static修饰的变量）**，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。

**解析:**

解析阶段是虚拟机在常量池内寻找类、接口、字段和方法的符号引用，并且将这些**符号引用替换为直接引用**的过程。符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。

**初始化:**

初始化阶段是类的加载过程的最后一个阶段，该阶段主要做一件事情就是执行&lt;clinit&gt;()，该方法**会为所有的静态变量赋予正确的值**。

参考文章：[万万没想到，JVM内存结构的面试题可以问的这么难？](https://mp.weixin.qq.com/s?__biz=MzI5NTYwNDQxNA==&mid=2247485214&idx=1&sn=32aa3d83464435188be9ac52c8e9c588&chksm=ec505ecfdb27d7d97897f74b36d28bc67536b55b0f252cb1f5f006b5a3439a2e70965f86a1ff&scene=0&xtrack=1&key=546b3b791faf1f5f02217e88c54f3b221d19b0d2e192b57f4847f7cf607d2c54b426e5e62c83ab9bd93c35a1b850ecf229accf8266fc1ac362a34ae7d687b9cc4a342ed4f54c7809a3e40847fff4160a&ascene=1&uin=MjQ3MzkwMTc2Mw==&devicetype=Windows+10&version=62060844&lang=zh_CN&pass_ticket=W35VcrckR39Y5Fn9My7l/KozGVDszT28Gg6T3fIMrYKZDiAMan7yl4BY759W+Uo+)

**23、Java内存泄漏的场景。**

内存泄漏是指，一个不再被程序使用的对象或变量还在内存中占有存储空间。虽然Java拥有GC，但还是会出现内存泄漏。举个例子。

```Java
//首先，要明白，GC它回收的是不可到达的对象，但是，在static 的集合类中，引用可以到达，但是却有可能对象已经不用了
//首先定义一个静态变量
public static ArrayList<Object> list = new ArrayList<Object>();
public void stackOverExam(Object object){
    //当非静态变量被static变量持有引用的时候，容易发生内存泄露，因为object是一直被list引用着的
    list.add(object);
    object = null;//这里设置为null并没有达到释放object引用对应对象的效果，毕竟list还是持有引用
}
```

通过上面的代码可以看到，由于static指向的对象是不能被垃圾回收器回收的，所以，间接的object也是无法被回收的，当业务对象很大而且很多的时候，便有了内存泄漏的风险。所以，可以总结如下规则：

当全局的静态变量持有局部变量（或者说，大范围的变量持有小范围变量而且小范围变量消耗内存表达、数目变多时），程序便有内存泄漏的风险。一般来说，类似的例子还有，单例模式中的对象，模块之间的调用（后面这个例子提到）等。

先举一个单例对象的例子。由于单例的静态特征使得其生命周期和应用的生命周期一样长，如果一个对象已经不再被使用，而单例对象还会持有该对象的引用，就会使得该对象不能被正常回收，从而导致了内存泄漏。

```java
public class Singleton {
    private static Singleton singleton;
    private List<Integer> list;
    private Singleton(List<Integer> list) {
        this.list = list;
    }
    public Singleton getInstance(List<Integer> list) {
        if (singleton == null) {
            singleton = new Singleton(list);
        }
        return singleton;
    }
}
```

另外再举一个模块调用的例子，现在有两个类A和B，其中B的默认构造函数上是需要一个A的实例作为参数的，这就让A和B产生了依赖。

```java
A a=new A();
B b=new B(a);
a=null;
```

a是对象A的引用，b是对象B的引用，对象B同时还依赖对象A，那么这个时候就可以认为对象B是可以到达对象A的。当A对象的引用a置为null后，a不再指向对象A的引用了，按理说对象A可以GC了。但是因为B依赖着A，所以这个时候，A对象是不可能被回收了，造成了内存泄漏。这个时候可以用弱引用WeakReference来代替对象B，就可以解决了这个问题。如下所示。

```java
A a=new A();
WeakReference wr=new WeakReference(a);
a=null;
```



**25、频繁GC的原因。**

- 人为因素，在代码中调用了System.gc()方法。
- 内存原因，设置的堆大小比较小，可以提高堆的空间，比如说提高最小堆空间-Xms和最大堆空间-Xmx的大小，当然，最好是针对内存的DUMP文件进行分析。
- 其他原因，构建的对象实例化十分频繁并且释放对象较为频繁时，也会引起频繁gc。

如果线上系统突然产生的运行缓慢问题，如果该问题导致线上系统不可用，那么首先需要做的就是，导出jstack和内存信息，然后重启系统，尽快保证系统的可用性。这种情况可能的原因主要有两种：

- 代码中某个位置读取数据量较大，导致系统内存耗尽，从而导致Full GC次数过多，系统缓慢；
- 代码中有比较耗CPU的操作，导致CPU过高，系统运行缓慢。

**26、高并发时，JVM调优。**

优化虚拟机堆的空间大小，根据实际物理内存的大小进行比例分配，并根据程序调整好新生代和老年代的比例。并且，堆不进行自动扩展。然后使用ParNew（并发）+CMS进行垃圾回收，在多线程高并发的情况下，表现很好。

调优的目标是：

- 将转移到老年代的对象数量降低到最小 。
- 减少Full GC的执行时间。

**27、System.gc()和Runtime.gc()的区别。**

- java.lang.System.gc()只是java.lang.Runtime.getRuntime().gc()的简写，两者的行为没有任何不同。

- System.gc()和runtime.gc()用于建议jvm进行垃圾回收，但是否立即回收还是延迟回收由Java虚拟机决定。

另外，当我们调用System.gc()的时候，其实并不会马上进行垃圾回收，甚至不一定会执行垃圾回收。


