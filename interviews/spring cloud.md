




马丁弗勒--提出微服务的概念，提出熔断概念。


**Hystrix**

服务雪崩：

-场景一：在微服务架构中，一个请求需要调用多个服务是非常常见的。如客户端访问 A 服务，而 A 服务需要调用 B 服务，B 服务需要调用 C 服务，由于网络原因或者自身的原因，如果 B 服务或者 C 服务不能及时响应，A 服务将处于阻塞状态，直到 B 服务 C 服务响应。此时若有大量的请求涌入，容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，造成连锁反应，会对整个微服务系统造成灾难性的严重后果，场景：

-场景二：当用户调用微服务A，微服务A调用微服务B，此时如果B对A响应超时，那么A会一直在运行，等待B的返回结果，将返回结果进行处理返回给客户端。从客户端来看，调用着A服务，A服务却响应很慢，会认为A服务出现了异常。其实此时A服务没有异常，只是B服务发生来异常，导致A服务响应慢。令微服务提供的服务需要运行3s，当2w个请求同时到一台微服务的服务器上，其他的请求过来，该请求的响应很慢，服务会卡死。

现象：在微服务的相互调用中，一旦一个服务出错，那么调用该服务的链路上的服务可能都会产生影响。

解决方法：

- 超时不再等待、宕机/出错要有兜底：设置微服务B自身调用超时时间的峰值。峰值内可正常响应；超过峰值时，使用fallback降级。

--实现方法：在被调用的请求方法上加@HystrixCommand(fallbackMethod="自定义方法名", 超时时间maxTime)。当超过maxTime时，或者B服务发生异常时，都会调用自定义方法，将出错信息返回给用户，这样用户不用等待太久，就可以得到响应。

Hystrix如何才会降级？
-1.程序运行发生异常。
-2.程序响应超时。
-3.服务发生熔断。
-4.线程池/信号量打满。

配置Hystrix：

一般降级都是在客户端的。在yml或者application的配置文件汇总配置feign.hystrix.enable = true。在启动类上加上@EnableHystrix。

上述服务降级的实现方法有两个重大缺点：
- 1.每个提供服务的方法都要配置兜底的服务降级fallbackMethod，这样代码会产生冗余情况。如果提供的服务有100个，那么要在controller中定义100个降级方法，太冗余。
- 2.controller中的业务代码和降级方法放在一个类中，使得代码耦合度过高，可读性差。

优化方法：
- 1.使用@DefaultProperties(defaultFallback="global自定义方法")修饰Controller类。这样controller类中每个方法只要加了@HystrixCommand，就默认使用defaultFallback内的降级方法。这种方法还是需要在controller类中配置全局的服务降级方法+特定的服务降级方法方法，使业务方法和降级方法耦合在一起。
- 2.在@FeignClient注解中加入fallback参数，构造一个Feign接口的实现类，实现类的方法就是服务的降级方法，将实现类配置到fallback参数中。这样当调用服务B时，一旦服务B异常，就会调用接口实现类的降级方法。这解决类代码冗余，代码耦合的问题。


**短路器/熔断器**

在@HystrixCommand中使用HystrixProperty属性，设置如果10个请求的失败率达到30%，就将服务进行熔断，以后每次调用该微服务，直接调用降级方法，而不是业务方法，直到过了5s后允许少量请求访问，尝试半开放，看此时微服务是否可用，如果请求成功，从半开到闭合。

配置方法：

在启动类上加入@EnableCircuitBreaker注解开启熔断器。



**RabbitMQ**

接口幂等问题：
-场景：微服务A访问微服务B，微服务B收到A的请求会修改数据库。
-问题：A和B使用HTTP连接，而HTTP连接的传输层使用TCP，TCP有超时重传机制。当微服务A向微服务B发起请求时，B需要话费大量时间处理该请求，因此微服务B没有在A的指定范围内返回响应，此时A认为响应已经超时，会重传HTTP请求。由于TCP的重传机制，会导致一个修改请求多次发送，这样数据库会多次修改，这就是接口幂等问题，这就是TCP的超时重传的弊端。
-解决办法：在请求中添加两个字段：全局唯一的userId和自增的version。同时在数据库中添加这两个字段。
--userId作用：对于接口是用于插入操作的，当多个同样的插入操作到数据库时，查询是否已经存在该userId，如果userId已存在，说明该请求是无用的重复请求。
--ABA问题：对于接口是用于修改操作的，当请求A1请求修改数据库时，此时超时了，在重传之前，请求A2请求修改同一条数据，修改成功，此时重传请求过来，又将数据改为来了，这就是ABA的问题。(删除其实就是修改is_active字段)。
--version作用：为了解决ABA问题，使用自增的version区分修改的次序，例如A1的原请求和重传请求的version都是1，新请求A2的version会自增变成2，数据库的version字段会变成2，每次修改时，如果数据库的version大于当前请求的version，该请求被认为无效请求。



MQ与多线程的取舍？服务雪崩？：
-场景：对于高并发场景，即同时有1w+请求到达服务B，每个请求都会创建一个线程，而64位的服务器线程数最多位7000左右。
-问题：B处理每个请求需要耗费大量时间，当前7000个请求还没响应，后面的请求由于申请不到线程资源而阻塞，请求会一直等待。这就是服务雪崩问题。
-底层分析：由于创建的线程过多，这些线程会竞争CPU资源，CPU会频繁切换线程，每个线程在切换时要保存线程，需要将线程数据存到使用CPU的寄存器中，这样线程多时，寄存器资源也不够用，服务会很卡。
-解决方法：使用消息中间件，将A的请求放到RabbitMQ中，B从MQ中取请求，这样A和B的服务就进行解耦了。同时高并发也不会打到B中，而是到达消息中间件中，由于消息中间件只负责存储请求，因此会很快就响应A，服务B从MQ中拿消息，虽然每次处理都很慢，但是由于每次处理完一个请求，才会取下一个请求，因此不会产生高并发问题。


消息队列满了，如何解决？
-1.队列满了，说明消费能力很低，此时可以将消费者做成集群。每个消费者通过offset取到唯一的请求。
-2.消息持久化到硬盘中。

MQ的幂等问题：
-消费者启动时，会从MQ中拉取一个请求，启动后，都是MQ想消费者推送消息的。消费者从MQ中取出一个请求，如果在MQ指定的时间内消费完成并响应给MQ，MQ就会从队列中删除该请求。如果消费者没有在指定时间内消费成功，就会重新向消费者发送该请求，产生幂等问题。
-解决方法：对每个消息加上messageId，如果已经存在该messageId，就认为是该消息是重传的，作为无效化处理。

MQ消息顺序问性：
-场景：三个消息分别是create,update,delete操作，如果是消费者是集群，那么可能三台机器分别拿到了这三条信息。这样update操作可能在create操作之前发生发生，因此破坏了原有逻辑的顺序性。
-解决方法：对具有顺序性的消息分区，将分区的消息放到一个消费者上。






