马丁弗勒--提出微服务的概念，提出类熔断概念。


**Hystrix**

场景：

当用户调用微服务A，微服务A调用微服务B，此时如果B对A响应超时，那么A会一直在运行，等待B的返回结果，将返回结果进行处理返回给客户端。从客户端来看，调用着A服务，A服务却响应很慢，会认为A服务出现了异常。其实此时A服务没有异常，只是B服务发生来异常，导致A服务响应慢。令微服务提供的服务需要运行3s，当2w个请求同时到一台微服务的服务器上，其他的请求过来，该请求的响应很慢，服务会卡死。

现象：在微服务的相互调用中，一旦一个服务出错，那么调用该服务的链路上的服务可能都会产生影响。

解决方法：

- 超时不再等待、宕机/出错要有兜底：设置微服务B自身调用超时时间的峰值。峰值内可正常响应；超过峰值时，使用fallback降级。

--实现方法：在被调用的请求方法上加@HystrixCommand(fallbackMethod="自定义方法名", 超时时间maxTime)。当超过maxTime时，或者B服务发生异常时，都会调用自定义方法，将出错信息返回给用户，这样用户不用等待太久，就可以得到响应。

Hystrix如何才会降级？
-1.程序运行发生异常。
-2.程序响应超时。
-3.服务发生熔断。
-4.线程池/信号量打满。

配置Hystrix：

一般降级都是在客户端的。在yml或者application的配置文件汇总配置feign.hystrix.enable = true。在启动类上加上@EnableHystrix。

上述服务降级的实现方法有两个重大缺点：
- 1.每个提供服务的方法都要配置兜底的服务降级fallbackMethod，这样代码会产生冗余情况。如果提供的服务有100个，那么要在controller中定义100个降级方法，太冗余。
- 2.controller中的业务代码和降级方法放在一个类中，使得代码耦合度过高，可读性差。

优化方法：
- 1.使用@DefaultProperties(defaultFallback="global自定义方法")修饰Controller类。这样controller类中每个方法只要加了@HystrixCommand，就默认使用defaultFallback内的降级方法。这种方法还是需要在controller类中配置全局的服务降级方法+特定的服务降级方法方法，使业务方法和降级方法耦合在一起。
- 2.在@FeignClient注解中加入fallback参数，构造一个Feign接口的实现类，实现类的方法就是服务的降级方法，将实现类配置到fallback参数中。这样当调用服务B时，一旦服务B异常，就会调用接口实现类的降级方法。这解决类代码冗余，代码耦合的问题。


**短路器/熔断器**

在@HystrixCommand中使用HystrixProperty属性，设置如果10个请求的失败率达到30%，就将服务进行熔断，以后每次调用该微服务，直接调用降级方法，而不是业务方法，直到过了5s后允许少量请求访问，尝试半开放，看此时微服务是否可用，如果请求成功，从半开到闭合。

配置方法：

在启动类上加入@EnableCircuitBreaker注解开启熔断器。



